## 垃圾收集器与内存分配策略

### 对象已死吗？

垃圾收集器在对堆进行回收前，第一件事情就是要确定哪些对象还活着，哪些已经死去（即不可能再被任何途径使用的对象）

1. **引用计数算法**

   给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。

   但是主流的Java虚拟机里并没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。

2. **可达性分析算法**

通过一系列的称为“**GC Roots**”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达时，则证明此对象是不可用的，即被判定为可被回收的对象。

在Java语言中，可作为GC Roots的对象包括以下几种：

- 虚拟机栈（栈帧中的本地变量表）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般所说的Native方法）引用的对象

3. **回收方法区**

在方法区进行垃圾收集的性价比比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95%的空间，而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分：**废弃常量**和**无用的类**。判定一个废弃常量比较简单，而要判定一个类是否是“无用的类”则条件相对苛刻许多。类同时需要满足以下三个条件才能算是“无用的类”：

- 该类所有的实例都已经被回收，也就是Java堆中不存在任何该类的实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

4. **垃圾收集算法**

   1. 标记-清除算法

   算法分为标记和清除两个阶段：首先标记出所有要回收的对象，在标记完成后统一回收所有被标记的对象。存在的不足有两个，一个是效率问题，一个是空间问题。这种算法会产生大量不连续的空间碎片，这会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存。

   ![1](/Users/tangkai/Desktop/1.jpeg)

   2. 复制算法

   将可用内存按容量分为大小相等两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。但是这种算法会将内存缩小为原来的一般，代价太高。

   现在的商业虚拟机都使用这种算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1.

   ![WechatIMG2](/Users/tangkai/Desktop/WechatIMG2.jpeg)

   3. 标记-整理算法

   根据老年代的特点，使用标记-整理算法进行垃圾收集，标记过程同第一种一样，但是后续步骤不是直接对可回收对象进行清理，而是将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。示意图如下：

   ![WechatIMG1](/Users/tangkai/Desktop/WechatIMG1.jpeg)

   **注：**第一次使用Typora上传图片，看看效果吧。